from datetime import date
from typing import List, Dict, Any, Set

class Room:
    """
    Class representing a hotel room in the Royal Stay Hotel Management System.

    This class manages room information including room details, pricing, and availability.
    """

    VALID_ROOM_TYPES = {"single", "double", "twin", "suite", "deluxe", "executive"}
    COMMON_AMENITIES = {
        "wifi", "tv", "airconditioning", "minibar", "safe", "bathroom",
        "bathtub", "shower", "hairdryer", "roomservice", "coffeemaker"
    }

    def __init__(self, room_number: int, room_type: str, price_per_night: float, amenities: List[str] = None) -> None:
        if room_type.lower() not in self.VALID_ROOM_TYPES:
            raise ValueError(f"Invalid room type. Must be one of: {', '.join(self.VALID_ROOM_TYPES)}")
        if price_per_night < 0:
            raise ValueError("Price per night cannot be negative")

        self._room_number = room_number
        self._room_type = room_type.lower()
        self._price_per_night = price_per_night
        self._amenities = amenities if amenities else []
        self._is_available = True
        self._booked_dates = set()

    @property
    def room_number(self) -> int:
        return self._room_number

    @property
    def room_type(self) -> str:
        return self._room_type

    @room_type.setter
    def room_type(self, value: str) -> None:
        value = value.lower()
        if value not in self.VALID_ROOM_TYPES:
            raise ValueError(f"Invalid room type. Must be one of: {', '.join(self.VALID_ROOM_TYPES)}")
        self._room_type = value

    @property
    def amenities(self) -> List[str]:
        return self._amenities.copy()

    def add_amenity(self, amenity: str) -> None:
        amenity = amenity.lower()
        if amenity not in self._amenities:
            self._amenities.append(amenity)

    def remove_amenity(self, amenity: str) -> bool:
        amenity = amenity.lower()
        if amenity in self._amenities:
            self._amenities.remove(amenity)
            return True
        return False

    @property
    def price_per_night(self) -> float:
        return self._price_per_night

    @price_per_night.setter
    def price_per_night(self, value: float) -> None:
        if value < 0:
            raise ValueError("Price per night cannot be negative")
        self._price_per_night = value

    @property
    def is_available(self) -> bool:
        return self._is_available

    @is_available.setter
    def is_available(self, value: bool) -> None:
        self._is_available = value

    def book_dates(self, checkin: date, checkout: date) -> bool:
        if checkout <= checkin:
            raise ValueError("Check-out date must be after check-in date")
        dates_to_book = {date.fromordinal(i) for i in range(checkin.toordinal(), checkout.toordinal())}
        if dates_to_book & self._booked_dates:
            return False
        self._booked_dates.update(dates_to_book)
        return True

    def cancel_booking(self, checkin: date, checkout: date) -> bool:
        if checkout <= checkin:
            raise ValueError("Check-out date must be after check-in date")
        dates_to_cancel = {date.fromordinal(i) for i in range(checkin.toordinal(), checkout.toordinal())}
        self._booked_dates -= dates_to_cancel
        return True

    def is_available_for_dates(self, checkin: date, checkout: date) -> bool:
        if checkout <= checkin:
            raise ValueError("Check-out date must be after check-in date")
        dates_to_check = {date.fromordinal(i) for i in range(checkin.toordinal(), checkout.toordinal())}
        return not bool(dates_to_check & self._booked_dates)

    def get_details(self) -> Dict[str, Any]:
        return {
            "room_number": self._room_number,
            "room_type": self._room_type,
            "price_per_night": self._price_per_night,
            "amenities": self._amenities,
            "is_available": self._is_available
        }

    def __str__(self) -> str:
        amenities_str = ", ".join(self._amenities) if self._amenities else "None"
        availability = "Available" if self._is_available else "Not Available"
        return (f"Room {self._room_number} ({self._room_type}): "
                f"${self._price_per_night:.2f} per night, "
                f"Amenities: {amenities_str}, "
                f"Status: {availability}")
